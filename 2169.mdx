---
title: LeetCode Challenge Day 55 â€” 2169. Count Operations to Obtain Zero  
summary: Day 55 of my LeetCode challenge! Todayâ€™s problem is "Count Operations to Obtain Zero" â€” a simple yet insightful problem based on the Euclidean algorithm concept, where we repeatedly subtract the smaller number from the larger one until both reach zero.  
solution: https://leetcode.com/problems/count-operations-to-obtain-zero/solutions/7336896/2169-count-operations-to-obtain-zero-by-cwmoz 
image:  
author: Nitin Ahirwal  
publishedAt: 2025-11-09  
tags: ["LeetCode Challenge", "Day 55", "Mathematics", "GCD", "Subtraction", "JavaScript", "Algorithm", "Easy", "Euclidean Algorithm"]  
---

## Hey folks ğŸ‘‹  

This is **Day 55** of my LeetCode streak ğŸš€  
Todayâ€™s problem is **2169. Count Operations to Obtain Zero** â€” an **easy** yet elegant math-based problem that builds directly on the **Euclidean algorithm** logic for finding GCDs, but with a twist â€” instead of returning the GCD, we count the total number of subtraction operations.

---

## ğŸ“Œ Problem Statement  

You are given two non-negative integers `num1` and `num2`.

In one operation:
- If `num1 >= num2`, you must subtract `num2` from `num1`.
- Otherwise, subtract `num1` from `num2`.

Return the **number of operations** required until either `num1` or `num2` becomes `0`.

**Example 1:**  
```
Input: num1 = 2, num2 = 3
Output: 3
Explanation:
Operation 1 â†’ num2 = 3 - 2 = 1
Operation 2 â†’ num1 = 2 - 1 = 1
Operation 3 â†’ num2 = 1 - 1 = 0
```

**Example 2:**  
```
Input: num1 = 10, num2 = 10
Output: 1
Explanation: num1 = num2 = 10 â†’ subtract once â†’ (0, 10)
```

---

## ğŸ’¡ Intuition  

At first glance, this looks like a repeated subtraction process â€” but thereâ€™s a pattern.  
The problem mirrors the **Euclidean GCD algorithm**, where instead of computing the GCD, we count **how many subtractions** it would take to reduce both numbers to zero.

Each subtraction operation group can be optimized:
- Instead of subtracting one by one, we can perform `Math.floor(num1 / num2)` operations in a single step â€” since thatâ€™s how many times `num2` fits inside `num1`.

---

## ğŸ”‘ Approach  

1. Initialize a `count` variable to store the total number of subtraction operations.
2. While both `num1` and `num2` are greater than zero:
   - If `num1 >= num2`, increment `count` by `Math.floor(num1 / num2)` and update `num1 = num1 % num2`.
   - Otherwise, increment `count` by `Math.floor(num2 / num1)` and update `num2 = num2 % num1`.
3. Once one number becomes zero, exit the loop.
4. Return the `count`.

This approach effectively simulates all subtraction steps without actually performing each one individually.

---

## â±ï¸ Complexity Analysis  

- **Time Complexity:**  
  \( O(\log(\min(num1, num2))) \) â€”  
  The process mimics the **Euclidean algorithm** for GCD which operates in logarithmic time.

- **Space Complexity:**  
  \( O(1) \) â€”  
  We only use a constant number of variables.

---

## ğŸ§‘â€ğŸ’» Code (JavaScript)

```javascript []
/**
 * @param {number} num1
 * @param {number} num2
 * @return {number}
 */
var countOperations = function(num1, num2) {
    let count = 0;
    while (num1 !== 0 && num2 !== 0) {
        if (num1 >= num2) {
            count += Math.floor(num1 / num2);
            num1 = num1 % num2;
        } else {
            count += Math.floor(num2 / num1);
            num2 = num2 % num1;
        }
    }
    return count;
};
```

### ğŸ§© Example Walkthrough

Input:

```num1 = 5, num2 = 4```


Process:
```
Step 1 â†’ 5 >= 4 â†’ count += 1 â†’ num1 = 1, num2 = 4  
Step 2 â†’ 4 >= 1 â†’ count += 4 â†’ num2 = 0  
Total count = 5
```

Output:

```5```

### ğŸ¯ Reflection

This problem is a great demonstration of how mathematical reasoning and optimization can simplify what seems like a loop-heavy process.
By thinking in terms of division and modulus instead of repetitive subtraction, we achieve an efficient and elegant solution.

Thatâ€™s it for Day 55 of my LeetCode challenge ğŸ’ª
Keep grinding and optimizing your thought process â€” one operation at a time âš¡

Happy Coding ğŸ‘¨â€ğŸ’»