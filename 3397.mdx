---
title: LeetCode Challenge Day 33 â€” Maximize Distinct Elements Within Range  
summary: Day 33 of my LeetCode challenge! Todayâ€™s problem is about picking distinct integers from flexible ranges. I explain the greedy interval strategy, why sorting by endpoints works, analyze complexity, and share my JavaScript solution.  
solution: https://leetcode.com/problems/maximum-number-of-distinct-elements-after-operations/solutions/7292869/3397-maximum-number-of-distinct-elements-h5lr
image:  
author: Nitin Ahirwal  
publishedAt: 2025-10-18  
tags: ["LeetCode Challenge", "Greedy", "Intervals", "JavaScript", "Medium", "Portfolio"]  
---

## Hey folks

This is **Day 33" of my LeetCode streak ðŸš€.  
Todayâ€™s problem is **Maximize Distinct Elements Within Range** â€” a **medium greedy + interval problem** where each number in an array gives us a range `[x - k, x + k]`, and we want to pick as many **distinct integers** as possible from these ranges.

---

## ðŸ“Œ Problem Statement

You are given:

- An array `nums`.  
- An integer `k`.  

For each number `x` in `nums`, you can choose a value in the interval `[x - k, x + k]`.  

Your goal is to maximize how many **distinct integers** you can pick overall.

---

## ðŸ’¡ Intuition

Each number defines a range of valid choices.  
To maximize distinct integers:
- We want to pick numbers in increasing order.  
- If we always pick the smallest possible integer thatâ€™s still valid, we leave more space for future picks.  

This is a classic **interval scheduling problem** â€” sort intervals by their right endpoint and greedily assign.

---

## ðŸ”‘ Approach

1. Build intervals for each number: `[x - k, x + k]`.  
2. Sort all intervals by their right endpoint.  
3. Keep track of the **last picked integer** (`cur`).  
4. For each interval:
   - Pick `max(cur + 1, l)` â€” the smallest valid integer larger than the last chosen.  
   - If itâ€™s â‰¤ `r`, accept it and increment the count.  
   - Otherwise, skip.  
5. Return the count.

---

## â±ï¸ Complexity Analysis

- **Time complexity:**  
  - Sorting intervals: $$O(n \log n)$$  
  - Greedy scan: $$O(n)$$  
  **Overall: $$O(n \log n)$$**

- **Space complexity:**  
  - Intervals array: $$O(n)$$  
  **Overall: $$O(n)$$**

---

## ðŸ§‘â€ðŸ’» Code (JavaScript)

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var maxDistinctElements = function(nums, k) {
  const intervals = nums.map(x => [x - k, x + k]);
  intervals.sort((a, b) => a[1] - b[1]); // sort by right endpoint

  let cur = -Infinity;
  let ans = 0;

  for (const [l, r] of intervals) {
    const pick = Math.max(cur + 1, l); // smallest valid integer > cur
    if (pick <= r) {
      ans++;
      cur = pick;
    }
  }
  return ans;
};
```

ðŸ§ª Example Walkthrough

Input:
nums = [2, 4, 6], k = 1

Intervals: [1,3], [3,5], [5,7]

Sorted by right endpoint: [1,3], [3,5], [5,7]

Greedy picks: 1 â†’ 3 â†’ 5

Output: 3.

ðŸŽ¥ Reflections

This problem highlights how interval scheduling ideas apply outside of scheduling.
The greedy choice of always picking the earliest possible valid number ensures maximum distinctness.

Thatâ€™s it for todayâ€™s challenge ðŸ’¡
Onwards to the next problem ðŸ”¥

Happy Coding ðŸ‘¨â€ðŸ’»
