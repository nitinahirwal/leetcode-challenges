---
title: LeetCode Challenge Day 28 â€” 2273. Find Resultant Array After Removing Anagrams  
summary: Day 28 of my LeetCode challenge! Todayâ€™s problem is "Find Resultant Array After Removing Anagrams". I explain the intuition of consecutive anagram removal, show how to use frequency signatures, analyze time and space complexity, and share my JavaScript solution.  
solution: https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/solutions/7271398/2273-find-resultant-array-after-removing-wvce 
image:  
author: Nitin Ahirwal  
publishedAt: 2025-10-13  
tags: ["LeetCode Challenge", "Day 28", "Hashing", "String", "JavaScript", "Easy", "Portfolio"]  
---

## Hey folks

This is **Day 28** of my LeetCode streak ðŸš€.  
Todayâ€™s problem is **2273. Find Resultant Array After Removing Anagrams** â€” an **easy string hashing** problem where we eliminate consecutive anagrams.

---

## ðŸ“Œ Problem Statement

You are given an array of words.  
- If two adjacent words are **anagrams**, remove the later one.  
- Keep repeating until no such consecutive pair exists.  

Return the resulting array.

---

## ðŸ’¡ Intuition

- Two words are anagrams if their character counts are identical.  
- So instead of checking by sorting each time, we generate a **frequency signature**.  
- Whenever two consecutive words share the same signature, we drop the later one.  
- Greedy works because order of removals doesnâ€™t matter (all lead to the same result).  

---

## ðŸ”‘ Approach

1. Create a helper `sig(word)` â†’ returns a frequency array of size 26, joined into a string.  
2. Iterate over words:
   - For each word, compute its signature.  
   - Compare with the last kept wordâ€™s signature.  
   - If same â†’ skip it.  
   - If different â†’ add it to the result.  
3. Return the result list.  

---

## â±ï¸ Complexity Analysis

- **Time complexity:**  
  For each word of length `L`, we compute a 26-char frequency. With `n` words, complexity is **O(n Â· L)**.  

- **Space complexity:**  
  Only a fixed 26-length array for counting, so extra space is **O(1)** (ignoring output).  

---

## ðŸ§‘â€ðŸ’» Code (JavaScript)

```js
/**
 * @param {string[]} words
 * @return {string[]}
 */
var removeAnagrams = function(words) {
  const res = [];
  let prevSig = null;

  const sig = (w) => {
    const cnt = new Array(26).fill(0);
    for (let i = 0; i < w.length; i++) cnt[w.charCodeAt(i) - 97]++;
    return cnt.join('#'); // delimiter avoids ambiguity
  };

  for (const w of words) {
    const curSig = sig(w);
    if (curSig !== prevSig) {
      res.push(w);
      prevSig = curSig;
    }
    // else skip â†’ it's an anagram of previous word
  }

  return res;
};
```

## ðŸ§ª Edge Cases

- Single word â†’ always returned as is.
    
- All words distinct â†’ nothing removed.
    
- All words anagrams â†’ only the first one remains.
    

---

## ðŸŽ¥ Reflections

This problem is a nice **string hashing warm-up**.  
Key lesson: when removing duplicates with structural equivalence (like anagrams), signatures simplify comparisons efficiently.

Thatâ€™s it for **Day 28** of my LeetCode journey!  
On to the next challenge ðŸ”¥

Happy Coding ðŸ‘¨â€ðŸ’»