---
title: LeetCode Challenge Day 37 â€” 3347. Maximum Frequency of an Element After Performing Operations II  
summary: Day 37 of my LeetCode challenge! Todayâ€™s problem is "Maximum Frequency of an Element After Performing Operations II". I explore how to use sweep line + difference arrays to track interval coverage, analyze complexity, and share my JavaScript solution.  
solution: https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/solutions/7292965/3347-maximum-frequency-of-an-element-aft-ivtz
image:  
author: Nitin Ahirwal  
publishedAt: 2025-10-22  
tags: ["LeetCode Challenge", "Day 37", "Greedy", "Sweep Line", "Difference Array", "JavaScript", "Medium", "Portfolio"]  
---

## Hey folks

This is **Day 37** of my LeetCode streak ğŸš€.  
Todayâ€™s problem is **3347. Maximum Frequency of an Element After Performing Operations II** â€” a **medium sweep line + difference array problem** where each number can be shifted within `[num - k, num + k]`, and we want to maximize the frequency of a single number after at most `numOperations`.

---

## ğŸ“Œ Problem Statement

You are given an array `nums`, and two integers `k` and `numOperations`.  

- Each number `x` can be converted into any integer in `[x - k, x + k]`.  
- You can perform at most `numOperations` conversions.  
- Return the maximum possible frequency of any number after the operations.

---

## ğŸ’¡ Intuition

Each number contributes an **interval of possible target values**.  
If we know:  
- How many numbers can reach a given target `T` (coverage).  
- How many numbers are already equal to `T`.  

Then we can calculate the maximum achievable frequency for `T` by combining existing equals with up to `numOperations` conversions from its coverage set.

---

## ğŸ”‘ Approach

1. **Frequency map**: Count occurrences of each exact number in `nums`.  

2. **Build interval coverage (difference array)**:  
   - For each number `x`, mark:  
     - `+1` at `x - k`  
     - `-1` at `x + k + 1`  
   - This way, a sweep across the number line maintains how many intervals currently cover a point.

3. **Sweep line**:  
   - Sort event positions and target values.  
   - Apply events left to right, keeping current coverage.  
   - Record coverage at each target and track global maximum coverage.  

4. **Compute best answer**:  
   - If `T` is not an existing number: `ans = min(numOperations, maxCoverage)`  
   - If `T` is an existing number:  
     ```
     candidate = min(freq(T) + numOperations, coverage(T))
     ```  
   - Take the maximum over all candidates.

---

## â±ï¸ Complexity Analysis

- **Time complexity:**  
  - Frequency map: **O(n)**  
  - Events + sorting: **O(n log n)**  
  - Sweep: **O(n)**  
  - Overall: **O(n log n)**  

- **Space complexity:**  
  - Frequency map, events, and coverage: **O(n)**  

---

## ğŸ§‘â€ğŸ’» Code (JavaScript)

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @param {number} numOperations
 * @return {number}
 */
var maxFrequency = function(nums, k, numOperations) {
  const n = nums.length;
  if (n === 0) return 0;

  // 1) frequency of exact values
  const freq = new Map();
  for (const x of nums) freq.set(x, (freq.get(x) || 0) + 1);

  // 2) build sweep events for intervals [x-k, x+k]
  const events = new Map();
  const addEvent = (pos, delta) => events.set(pos, (events.get(pos) || 0) + delta);

  for (const x of nums) {
    const L = x - k;
    const R = x + k;
    addEvent(L, 1);
    addEvent(R + 1, -1);
  }

  const eventPos = Array.from(events.keys()).sort((a, b) => a - b);
  const targets = Array.from(freq.keys()).sort((a, b) => a - b);

  // 3) sweep to record coverage at targets + max coverage
  let e = 0, t = 0;
  let cur = 0, maxCov = 0;
  const covAt = new Map();

  while (e < eventPos.length || t < targets.length) {
    const nextE = e < eventPos.length ? eventPos[e] : Infinity;
    const nextT = t < targets.length ? targets[t] : Infinity;

    if (nextT < nextE) {
      covAt.set(nextT, cur);
      t++;
    } else if (nextE < nextT) {
      cur += events.get(nextE);
      if (cur > maxCov) maxCov = cur;
      e++;
    } else {
      cur += events.get(nextE);
      if (cur > maxCov) maxCov = cur;
      e++;
      while (t < targets.length && targets[t] === nextT) {
        covAt.set(targets[t], cur);
        t++;
      }
    }
  }

  // 4) compute best answer
  let ans = Math.min(numOperations, maxCov); // when T is not an existing value
  for (const v of targets) {
    const f = freq.get(v);
    const cov = covAt.get(v) || 0;
    const candidate = Math.min(f + numOperations, cov);
    if (candidate > ans) ans = candidate;
  }
  return ans;
};
```

## ğŸ§ª Example Walkthrough

Input:
nums = [1,4,5], k = 1, numOperations = 2

Intervals:

1 â†’ [0,2]

4 â†’ [3,5]

5 â†’ [4,6]

Candidate = 4:

equal = 1 (the 4)

coverNonEqual = 1 (the 5 can move to 4)

With 2 operations available â†’ freq = 2

Output: 2

## ğŸ¥ Reflections

This problem is an elegant mix of interval coverage, sweep line, and greedy adjustment.
The difference array ensures efficient handling of ranges without brute force enumeration.

Thatâ€™s it for Day 37 of my LeetCode journey!
Onwards to the next challenge ğŸ”¥

Happy Coding ğŸ‘¨â€ğŸ’»