---
title: LeetCode Challenge Day 15 â€” 2221. Find Triangular Sum of an Array  
summary: Day 15 of my LeetCode challenge! Todayâ€™s problem is "Find Triangular Sum of an Array". I walk through the intuition, explain the simulation approach, discuss time and space complexity, and share my JavaScript solution.  
solution: https://leetcode.com/problems/find-triangular-sum-of-an-array/solutions/7236461/2221-find-triangular-sum-of-an-array-by-2cxpu 
image:  
author: Nitin Ahirwal  
publishedAt: 2025-09-30  
tags: ["LeetCode Challenge", "Day 15", "Simulation", "JavaScript", "Array", "Medium", "Portfolio"]
---
## Hey folks

This is **Day 15** of my LeetCode streak ðŸš€.  
Todayâ€™s problem is **2221. Find Triangular Sum of an Array** â€” weâ€™re given an array of digits, and we need to keep reducing it by replacing each pair of adjacent elements with their sum modulo 10, until only one element remains.

It looks like a simple array reduction, and simulating the process works perfectly here âœ¨.

---

## ðŸ“Œ Problem Statement

You are given a 0-indexed integer array `nums`, where each element is between 0 and 9.

At each step, form a new array of length `n-1` where `newNums[i] = (nums[i] + nums[i+1]) % 10`.  
Replace `nums` with `newNums` and continue until only one element remains.

Return the **last remaining element**.

### Example

- Input: `nums = [1,2,3,4,5]`  
    Output: `8`
    

Explanation:

```
[1,2,3,4,5]  
 â†’ [3,5,7,9]  
 â†’ [8,2,6]  
 â†’ [0,8]  
 â†’ [8]

```

### Constraints

- `1 <= nums.length <= 1000`
    
- `0 <= nums[i] <= 9`
    

---

## ðŸ’¡ Intuition

Each step reduces the size of the array by one until only one element remains.

This process is similar to Pascalâ€™s Triangle and binomial coefficients, but since `n <= 1000`, we donâ€™t need heavy math â€” **direct simulation is good enough**.

---

## ðŸ”‘ Approach

1. While the array length is greater than 1:
    
    - Create a new array `newNums`.
        
    - For each `i`, compute `(nums[i] + nums[i+1]) % 10`.
        
    - Replace `nums` with `newNums`.
        
2. Return the last remaining number.
    

---

## â±ï¸ Complexity Analysis

- **Time complexity:** O(nÂ²) â€” in each step the array size decreases by 1, so the total work is about n + (n-1) + ... + 1.
    
- **Space complexity:** O(n) â€” we store one extra array of size `n-1` at most.

## ðŸ§‘â€ðŸ’» Code (JavaScript)

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var triangularSum = function(nums) {
    while (nums.length > 1) {
        let newNums = [];
        for (let i = 0; i < nums.length - 1; i++) {
            newNums.push((nums[i] + nums[i + 1]) % 10);
        }
        nums = newNums;
    }
    return nums[0];
};

// âœ… Quick tests
console.log(triangularSum([1,2,3,4,5])); // 8
console.log(triangularSum([5]));         // 5
```

## ðŸ§ª Edge Cases

- Single element array â†’ return the element itself.
    
- All zeros â†’ always reduces to 0.
    
- Max length (1000) â†’ still fine within O(nÂ²).
    

---

## ðŸŽ¥ Reflections

This problem looks tricky at first, but itâ€™s basically **simulation with mod 10**.  
Itâ€™s also a neat reminder of how Pascalâ€™s triangle and binomial coefficients appear in such reduction problems â€” though brute-force is totally fine here.

We also completed **Day 15** âœ… â€” a small win, but consistent progress matters.  
On to the next challenge ðŸ”¥

Happy Coding ðŸ‘¨â€ðŸ’»