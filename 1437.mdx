---
title: LeetCode Challenge Day 63 â€” 1437. Check If All 1's Are at Least Length K Places Away
summary: Day 63 of my LeetCode challenge! Todayâ€™s problem is "1437. Check If All 1's Are at Least Length K Places Away" â€” a simple but elegant linear scan using distance tracking.
solution: https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/solutions/7355670/1437-check-if-all-1s-are-at-least-length-nncf
image:
author: Nitin Ahirwal
publishedAt: 2025-11-17
tags: ["LeetCode Challenge", "Day 63", "Binary Array", "Greedy", "JavaScript", "Easy"]
---

## Hey folks ðŸ‘‹

This is **Day 63** of my LeetCode streak ðŸš€  
Todayâ€™s problem is **1437 â€” Check If All 1's Are at Least Length K Places Away**.

A clean and efficient check:  
Make sure **every pair of 1s** in the binary array has **at least `k` zeros** between them.

---

## ðŸ’¡ Intuition

The idea is simple:

Whenever we encounter a `1`, we only need to check how far it is from the **previous `1`**.

- If the gap is less than `k`, return `false`
- Otherwise, update the last-seen position

This avoids scanning extra ranges or constructing substrings â€” just a **distance check**.

---

## ðŸ“Œ Approach

1. Start with `prev = -k - 1` so the first `1` always passes the check.  
2. Traverse the array:
   - When you see a `1` at index `i`:
     - Check if `i - prev - 1 < k`
     - If true â†’ not enough zeros â†’ return `false`
     - Else, update `prev = i`
3. If no violations occur, return `true`.

A single left-to-right pass solves it.

---

## ðŸ“ˆ Complexity

- **Time Complexity:** `O(n)` â€” one scan  
- **Space Complexity:** `O(1)` â€” constant extra space

---

## ðŸ§‘â€ðŸ’» Code (JavaScript)

```javascript []
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var kLengthApart = function(nums, k) {
    // prev initialized so the first 1 always passes the check
    let prev = -k - 1;
    
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === 1) {
            if (i - prev - 1 < k) return false;
            prev = i;
        }
    }
    return true;
};
```

## ðŸŽ¯ Example

Input:  
`nums = [1,0,0,0,1,0,0], k = 2`  
Output:  
`true`

Because the distance between the two `1`s is exactly 3 â†’ satisfies `k = 2`.

---

## ðŸ§  Reflection

This problem highlights how a **single pointer** and a **simple invariant** can solve what looks like a spacing constraint problem.

Key takeaways:

- Track what matters (the last seen `1`)
    
- Validate only the required condition
    
- Avoid extra data structures
    

See you tomorrow for **Day 64**! ðŸš€  
Happy Coding ðŸ‘¨â€ðŸ’»âœ¨